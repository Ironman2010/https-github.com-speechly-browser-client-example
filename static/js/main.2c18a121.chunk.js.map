{"version":3,"sources":["index.ts"],"names":["updateReady","contextId","isReady","readyDiv","document","getElementById","innerHTML","logResponse","type","segmentId","data","logDiv","JSON","stringify","window","onload","client","appId","process","language","Client","newClient","e","status","statusDiv","updateStatus","message","onSegmentChange","segment","words","entities","intent","map","word","isFinal","value","join","index","entity","t","startPosition","endPosition","onTentativeIntent","cid","sid","onTentativeEntities","onTentativeTranscript","transcript","onIntent","onEntity","onTranscript","recordDiv","startRecording","event","preventDefault","startContext","err","console","error","resetState","stopRecording","stopContext","addEventListener","onStateChange","state","ClientState","Connected","Stopping","setAttribute","removeAttribute","stateToString","bindStartStop","isInitialized","initDiv","initialize","button","target","close","bindInitialize"],"mappings":"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","file":"static/js/main.2c18a121.chunk.js","sourcesContent":["import {\n  Client,\n  ClientState,\n  stateToString,\n  Word,\n  Entity,\n  Intent,\n} from \"@speechly/browser-client\";\n\nwindow.onload = () => {\n  let client: Client;\n\n  try {\n    client = newClient();\n  } catch (e) {\n    updateStatus(e.message);\n    return;\n  }\n\n  // High-level API, that you can use to react to segment changes.\n  client.onSegmentChange((segment) => {\n    updateWords(segment.words);\n    updateEntities(segment.entities);\n    updateIntent(segment.intent);\n\n    if (segment.isFinal) {\n      updateReady(segment.contextId, true);\n    }\n  });\n\n  // This is low-level API, that you can use to react to tentative events.\n  client.onTentativeIntent((cid, sid, intent) =>\n    logResponse(\"tentative_intent\", cid, sid, { intent })\n  );\n  client.onTentativeEntities((cid, sid, entities) =>\n    logResponse(\"tentative_entities\", cid, sid, { entities })\n  );\n  client.onTentativeTranscript((cid, sid, words, transcript) =>\n    logResponse(\"tentative_transcript\", cid, sid, { words, transcript })\n  );\n\n  // This is low-level API, that you can use to react to final events.\n  client.onIntent((cid, sid, intent) =>\n    logResponse(\"intent\", cid, sid, { intent })\n  );\n  client.onEntity((cid, sid, entity) =>\n    logResponse(\"entity\", cid, sid, { entity })\n  );\n  client.onTranscript((cid, sid, word) =>\n    logResponse(\"transcript\", cid, sid, { word })\n  );\n\n  bindStartStop(client);\n  bindInitialize(client);\n};\n\nfunction newClient(): Client {\n  const appId = process.env.REACT_APP_APP_ID;\n  if (appId === undefined) {\n    throw Error(\"Missing Speechly App ID!\");\n  }\n\n  const language = process.env.REACT_APP_LANGUAGE;\n  if (language === undefined) {\n    throw Error(\"Missing Speechly language!\");\n  }\n\n  return new Client({ appId, language });\n}\n\nfunction updateWords(words: Word[]) {\n  const transcriptDiv = document.getElementById(\n    \"transcript-words\"\n  ) as HTMLElement;\n\n  transcriptDiv.innerHTML = words\n    .map((word) => (word.isFinal ? `<b>${word.value}</b>` : word.value))\n    .join(\" \");\n\n  const wordsDiv = document.getElementById(\"transcript-list\") as HTMLElement;\n  wordsDiv.innerHTML = words\n    .map((word) =>\n      word.isFinal\n        ? `<li><b>${word.value} [${word.index}]</b></li>`\n        : `<li>${word.value} [${word.index}]</li>`\n    )\n    .join(\"\");\n}\n\nfunction updateEntities(entities: Entity[]) {\n  const entitiesDiv = document.getElementById(\"entities-list\") as HTMLElement;\n\n  entitiesDiv.innerHTML = entities\n    .map((entity) => {\n      const t = `${entity.type} - ${entity.value} [${entity.startPosition} - ${entity.endPosition})`;\n      if (entity.isFinal) {\n        return `<li><b>${t}</b></li>`;\n      }\n      return `<li>${t}</li>`;\n    })\n    .join(\"\");\n}\n\nfunction updateIntent(intent: Intent) {\n  const intentDiv = document.getElementById(\"intent-value\") as HTMLElement;\n\n  intentDiv.innerHTML = intent.isFinal\n    ? `<b>${intent.intent}</b>`\n    : intent.intent;\n}\n\nfunction updateReady(contextId: string, isReady: boolean) {\n  const readyDiv = document.getElementById(\"final\") as HTMLElement;\n\n  if (isReady) {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId} Done!`;\n  } else {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId}`;\n  }\n}\n\nfunction logResponse(\n  type: string,\n  contextId: string,\n  segmentId: number,\n  data: any\n) {\n  const logDiv = document.getElementById(\"log-list\") as HTMLElement;\n\n  logDiv.innerHTML =\n    `<tr>\n          <td>${contextId}</td>\n          <td>${segmentId}</td>\n          <td>${type}</td>\n          <td>${JSON.stringify(data)}</td>\n        </tr>` + logDiv.innerHTML;\n}\n\nfunction updateStatus(status: string): void {\n  const statusDiv = document.getElementById(\"status\");\n  if (statusDiv === null) {\n    return;\n  }\n\n  statusDiv.innerHTML = status;\n}\n\nfunction bindStartStop(client: Client) {\n  const recordDiv = document.getElementById(\"record\") as HTMLElement;\n  recordDiv.addEventListener(\"mousedown\", startRecording);\n  recordDiv.addEventListener(\"touchstart\", startRecording);\n  recordDiv.addEventListener(\"mouseup\", stopRecording);\n  recordDiv.addEventListener(\"touchend\", stopRecording);\n\n  client.onStateChange((state) => {\n    if (state < ClientState.Connected || state === ClientState.Stopping) {\n      recordDiv.setAttribute(\"disabled\", \"true\");\n    } else {\n      recordDiv.removeAttribute(\"disabled\");\n    }\n\n    const statusDiv = document.getElementById(\"status\") as HTMLElement;\n    statusDiv.innerHTML = stateToString(state);\n  });\n\n  function startRecording(event: MouseEvent | TouchEvent) {\n    event.preventDefault();\n\n    client.startContext((err, contextId) => {\n      if (err) {\n        console.error(\"Could not start recording\", err);\n        return;\n      }\n\n      resetState(contextId as string);\n    });\n  }\n\n  function stopRecording(event: MouseEvent | TouchEvent) {\n    event.preventDefault();\n\n    client.stopContext((err) => {\n      if (err) {\n        console.error(\"Could not stop recording\", err);\n        return;\n      }\n    });\n  }\n}\n\nfunction bindInitialize(client: Client) {\n  let isInitialized = false;\n\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n  initDiv.addEventListener(\"mousedown\", initialize);\n  initDiv.addEventListener(\"touchstart\", initialize);\n\n  function initialize(event: MouseEvent | TouchEvent) {\n    event.preventDefault();\n    const button = event.target as HTMLElement;\n\n    if (!isInitialized) {\n      client.initialize((err) => {\n        if (err) {\n          console.error(\"Error initializing Speechly client:\", err);\n          return;\n        }\n\n        isInitialized = true;\n        button.innerHTML = \"Disconnect\";\n      });\n    } else {\n      client.close((err) => {\n        if (err) {\n          console.error(\"Error initializing Speechly client:\", err);\n          return;\n        }\n\n        isInitialized = false;\n        button.innerHTML = \"Connect\";\n      });\n    }\n  }\n}\n\nfunction resetState(contextId: string) {\n  updateReady(contextId, false);\n\n  const transcript = document.getElementById(\"transcript-words\") as HTMLElement;\n  transcript.innerHTML = \"\";\n\n  const transcriptList = document.getElementById(\n    \"transcript-list\"\n  ) as HTMLElement;\n  transcriptList.innerHTML = \"\";\n\n  const logList = document.getElementById(\"log-list\") as HTMLElement;\n  logList.innerHTML = \"\";\n\n  const entitiesList = document.getElementById(\"entities-list\") as HTMLElement;\n  entitiesList.innerHTML = \"\";\n}\n"],"sourceRoot":""}